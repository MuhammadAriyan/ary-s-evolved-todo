# Data Model: Full-Stack Web Application

**Feature**: 001-fullstack-web-app
**Date**: 2026-01-06
**Status**: Approved

## Overview

This document defines the data model for the full-stack todo application. The model supports multi-user isolation, task management with tags, priorities, due dates, and recurring patterns.

---

## Entities

### 1. User

**Description**: Represents a registered user account. Managed by Better Auth library.

**Attributes**:
- `id` (TEXT, PRIMARY KEY): Unique user identifier generated by Better Auth
- `email` (TEXT, UNIQUE, NOT NULL): User's email address for authentication
- `name` (TEXT, NULLABLE): User's display name
- `email_verified` (BOOLEAN, DEFAULT FALSE): Whether email has been verified
- `created_at` (TIMESTAMP, DEFAULT NOW()): Account creation timestamp
- `updated_at` (TIMESTAMP, DEFAULT NOW()): Last account update timestamp

**Relationships**:
- One-to-Many with Task (one user has many tasks)

**Validation Rules**:
- Email must be valid format (validated by Better Auth)
- Email must be unique across all users
- Password minimum 8 characters (validated by Better Auth)

**State Transitions**:
- Created → Email Verified (when user verifies email)
- Active → Deleted (when user deletes account, cascades to tasks)

---

### 2. Task

**Description**: Represents a todo item belonging to a specific user.

**Attributes**:
- `id` (SERIAL, PRIMARY KEY): Auto-incrementing task identifier
- `user_id` (TEXT, FOREIGN KEY → users.id, NOT NULL): Owner of the task
- `title` (VARCHAR(200), NOT NULL): Task title/summary
- `description` (TEXT, NULLABLE): Detailed task description
- `completed` (BOOLEAN, DEFAULT FALSE): Completion status
- `priority` (VARCHAR(10), NOT NULL, CHECK): Task priority (High, Medium, Low)
- `tags` (TEXT[], DEFAULT '{}'): Array of tag strings for organization
- `due_date` (DATE, NULLABLE): When the task is due
- `recurring` (VARCHAR(20), NULLABLE, CHECK): Recurrence pattern (daily, weekly, monthly)
- `created_at` (TIMESTAMP, DEFAULT NOW()): Task creation timestamp
- `updated_at` (TIMESTAMP, DEFAULT NOW()): Last task update timestamp

**Relationships**:
- Many-to-One with User (many tasks belong to one user)
- Foreign key constraint: `user_id` REFERENCES `users(id)` ON DELETE CASCADE

**Validation Rules**:
- `title`: Required, max 200 characters
- `description`: Optional, max 2000 characters
- `priority`: Must be one of: "High", "Medium", "Low"
- `tags`: Max 10 tags per task, each tag max 50 characters, case-insensitive
- `recurring`: If set, must be one of: "daily", "weekly", "monthly"
- `user_id`: Must reference existing user

**State Transitions**:
- Created (completed=false) → Completed (completed=true)
- Completed → Reopened (completed=false)
- Active → Deleted (permanent removal)

**Business Rules**:
- User can only access their own tasks (enforced by user_id filter)
- Recurring tasks generate new instances automatically via scheduler
- Completing a recurring task only marks that instance as complete
- Deleting a recurring task does not delete future instances (they're separate records)

---

## Indexes

### Performance Optimization

1. **idx_tasks_user_id** ON tasks(user_id)
   - **Purpose**: Optimize user isolation queries (most common query pattern)
   - **Type**: B-tree index
   - **Impact**: Critical for performance, used in every task query

2. **idx_tasks_completed** ON tasks(completed)
   - **Purpose**: Optimize filtering by completion status
   - **Type**: B-tree index
   - **Impact**: Used for "All/Pending/Completed" filters

3. **idx_tasks_due_date** ON tasks(due_date)
   - **Purpose**: Optimize calendar view and sorting by due date
   - **Type**: B-tree index
   - **Impact**: Used for calendar queries and date-based sorting

4. **idx_tasks_tags** ON tasks USING GIN(tags)
   - **Purpose**: Optimize tag filtering queries
   - **Type**: GIN (Generalized Inverted Index) for array containment
   - **Impact**: Enables efficient "contains tag" queries

---

## Database Schema (SQL)

```sql
-- Users table (managed by Better Auth)
CREATE TABLE users (
    id TEXT PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    email_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Tasks table
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    completed BOOLEAN DEFAULT FALSE,
    priority VARCHAR(10) NOT NULL CHECK (priority IN ('High', 'Medium', 'Low')),
    tags TEXT[] DEFAULT '{}',
    due_date DATE,
    recurring VARCHAR(20) CHECK (recurring IN ('daily', 'weekly', 'monthly')),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_completed ON tasks(completed);
CREATE INDEX idx_tasks_due_date ON tasks(due_date);
CREATE INDEX idx_tasks_tags ON tasks USING GIN(tags);
```

---

## SQLModel Models (Python)

```python
# backend/app/models/user.py
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional

class User(SQLModel, table=True):
    """User model (managed by Better Auth)."""
    __tablename__ = "users"

    id: str = Field(primary_key=True)
    email: str = Field(unique=True, index=True)
    name: Optional[str] = None
    email_verified: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

```python
# backend/app/models/task.py
from sqlmodel import SQLModel, Field, Column
from sqlalchemy import ARRAY, String
from datetime import datetime, date
from typing import Optional, List
from enum import Enum

class Priority(str, Enum):
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"

class Recurring(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"

class Task(SQLModel, table=True):
    """Task model with user isolation."""
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=200)
    description: Optional[str] = None
    completed: bool = Field(default=False)
    priority: Priority
    tags: List[str] = Field(default=[], sa_column=Column(ARRAY(String)))
    due_date: Optional[date] = None
    recurring: Optional[Recurring] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

---

## TypeScript Types (Frontend)

```typescript
// frontend/types/task.ts

export type Priority = "High" | "Medium" | "Low";
export type Recurring = "daily" | "weekly" | "monthly";

export interface User {
  id: string;
  email: string;
  name?: string;
  email_verified: boolean;
  created_at: string;
  updated_at: string;
}

export interface Task {
  id: number;
  user_id: string;
  title: string;
  description?: string;
  completed: boolean;
  priority: Priority;
  tags: string[];
  due_date?: string; // ISO date string
  recurring?: Recurring;
  created_at: string;
  updated_at: string;
}

export interface CreateTaskInput {
  title: string;
  description?: string;
  priority?: Priority;
  tags?: string[];
  due_date?: string;
  recurring?: Recurring;
}

export interface UpdateTaskInput {
  title?: string;
  description?: string;
  priority?: Priority;
  tags?: string[];
  due_date?: string;
  recurring?: Recurring;
}
```

---

## Migration Strategy

### Initial Migration (Alembic)

```python
# backend/alembic/versions/001_initial.py
"""Initial migration: users and tasks tables

Revision ID: 001
Revises:
Create Date: 2026-01-06
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    # Create users table
    op.create_table(
        'users',
        sa.Column('id', sa.Text(), nullable=False),
        sa.Column('email', sa.Text(), nullable=False),
        sa.Column('name', sa.Text(), nullable=True),
        sa.Column('email_verified', sa.Boolean(), server_default='false', nullable=False),
        sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email')
    )

    # Create tasks table
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer(), nullable=False, autoincrement=True),
        sa.Column('user_id', sa.Text(), nullable=False),
        sa.Column('title', sa.String(length=200), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('completed', sa.Boolean(), server_default='false', nullable=False),
        sa.Column('priority', sa.String(length=10), nullable=False),
        sa.Column('tags', postgresql.ARRAY(sa.Text()), server_default='{}', nullable=False),
        sa.Column('due_date', sa.Date(), nullable=True),
        sa.Column('recurring', sa.String(length=20), nullable=True),
        sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
        sa.CheckConstraint("priority IN ('High', 'Medium', 'Low')", name='check_priority'),
        sa.CheckConstraint("recurring IS NULL OR recurring IN ('daily', 'weekly', 'monthly')", name='check_recurring')
    )

    # Create indexes
    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('idx_tasks_completed', 'tasks', ['completed'])
    op.create_index('idx_tasks_due_date', 'tasks', ['due_date'])
    op.create_index('idx_tasks_tags', 'tasks', ['tags'], postgresql_using='gin')

def downgrade():
    op.drop_index('idx_tasks_tags', table_name='tasks')
    op.drop_index('idx_tasks_due_date', table_name='tasks')
    op.drop_index('idx_tasks_completed', table_name='tasks')
    op.drop_index('idx_tasks_user_id', table_name='tasks')
    op.drop_table('tasks')
    op.drop_table('users')
```

---

## Data Access Patterns

### Common Queries

1. **List user's tasks with filters**:
```python
# Filter by user_id (always required)
tasks = db.query(Task).filter(Task.user_id == current_user.id)

# Optional filters
if tag:
    tasks = tasks.filter(Task.tags.contains([tag]))
if priority:
    tasks = tasks.filter(Task.priority == priority)
if completed is not None:
    tasks = tasks.filter(Task.completed == completed)

# Sorting
if sort == "priority":
    tasks = tasks.order_by(Task.priority.desc())
elif sort == "due_date":
    tasks = tasks.order_by(Task.due_date.asc())
else:
    tasks = tasks.order_by(Task.created_at.desc())

tasks = tasks.all()
```

2. **Create task with user isolation**:
```python
task = Task(
    **task_data.dict(),
    user_id=current_user.id  # Automatically set from JWT
)
db.add(task)
db.commit()
```

3. **Get task with user isolation check**:
```python
task = db.query(Task).filter(
    Task.id == task_id,
    Task.user_id == current_user.id  # Security: verify ownership
).first()

if not task:
    raise HTTPException(status_code=404, detail="Task not found")
```

4. **Find recurring tasks due for generation**:
```python
today = datetime.now().date()
recurring_tasks = db.query(Task).filter(
    Task.recurring.isnot(None),
    Task.due_date <= today
).all()
```

---

## Security Considerations

1. **User Isolation**: Every query MUST filter by `user_id` from authenticated JWT token
2. **Cascade Delete**: When user is deleted, all their tasks are automatically deleted
3. **Input Validation**: All inputs validated by Pydantic schemas before database operations
4. **SQL Injection**: Prevented by SQLModel parameterized queries
5. **Authorization**: Dependency injection ensures `current_user` is authenticated before any query

---

**Data Model Status**: ✅ Complete
**Next**: Generate API contracts and quickstart guide
