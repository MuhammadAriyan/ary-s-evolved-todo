# Implementation Plan: Full-Stack Web Application Transformation

**Branch**: `001-fullstack-web-app` | **Date**: 2026-01-06 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-fullstack-web-app/spec.md`

## Summary

Transform the existing Python console todo app into a production-ready full-stack web application with Next.js 15+ frontend, FastAPI backend, Neon PostgreSQL database, and Better Auth authentication. The application will feature user registration (email/password + Google OAuth), JWT-based authentication, tag-based organization, animated calendar view, and recurring task scheduling. Architecture follows monorepo structure with strict user data isolation and stateless JWT authentication.

## Technical Context

**Language/Version**:
- Frontend: TypeScript 5.3+, Node.js 18+
- Backend: Python 3.12+

**Primary Dependencies**:
- Frontend: Next.js 15.1.0+, React 19+, shadcn/ui, Tailwind CSS 3.4+, Better Auth 1.0+, TanStack Query 5.0+, React Hook Form 7.50+, Zod 3.22+, react-big-calendar 1.8+
- Backend: FastAPI 0.109+, SQLModel 0.0.14+, Alembic 1.13+, PyJWT 2.8+, APScheduler 3.10+, Uvicorn 0.27+

**Storage**: Neon PostgreSQL (serverless) with tables: users (Better Auth managed), tasks (user_id FK), indexes on user_id, completed, tags (GIN array), due_date

**Testing**:
- Backend: pytest with coverage for task CRUD, user isolation, JWT verification, recurring task logic
- Frontend: Manual testing for authentication flows, UI interactions, mobile responsiveness

**Target Platform**:
- Frontend: Vercel (serverless Next.js deployment)
- Backend: Hugging Face Spaces or Railway/Render (Docker container)
- Database: Neon PostgreSQL (serverless, auto-scaling)

**Project Type**: Web application (monorepo with frontend/ and backend/ directories)

**Performance Goals**:
- API response time: <200ms p95 for CRUD operations
- Todo operations: <1 second from user action to completion
- Calendar view load: <2 seconds
- Tag filtering: <500ms
- Support 100+ concurrent users without degradation

**Constraints**:
- Stateless JWT authentication (no server-side sessions)
- User data isolation enforced at database query level
- All API endpoints require authentication except registration/login
- Input validation on both client and server
- HTTPS required in production
- Monorepo structure with clear frontend/backend separation

**Scale/Scope**:
- Target: 100+ concurrent users
- Average user: <500 todos
- JWT token expiry: 24 hours
- Recurring task scheduler: runs every minute
- Tag limit: 10 tags per todo, 50 characters per tag
- Title limit: 200 characters, description: 2000 characters

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### ✅ Spec-Driven Development Enforcement (Section I)
- [x] Feature begins with `sp.specify` (completed: spec.md created)
- [x] Implementation plan created via `sp.plan` (this document)
- [ ] Tasks will be generated by `sp.tasks` (pending after plan approval)
- [ ] Code implemented via `sp.implement` (pending after tasks)
- [x] All changes trace back to approved spec (spec.md → plan.md → tasks.md → implementation)

### ✅ Technology Stack Compliance (Section II - Phase II)
- [x] Frontend: Next.js 15+ (App Router), TypeScript, Tailwind CSS ✓
- [x] Backend: FastAPI, SQLModel ORM, Neon PostgreSQL ✓
- [x] Authentication: Better Auth with JWT tokens (shared secret, stateless) ✓
- [x] User isolation enforced at database query level ✓

### ✅ Architecture and Design Principles (Section III)
- [x] **Stateless Services**: Chat and API endpoints are stateless, all state in database ✓
- [x] **Multi-User Isolation**: Every query filters by authenticated user_id ✓
- [x] **JWT Verification**: Middleware required for all protected endpoints ✓
- [x] **Database Schema**: Users table (Better Auth), Tasks table with user_id FK ✓

### ⚠️ MCP Tools Specification (Section III)
- **Status**: NOT APPLICABLE for Phase II
- **Rationale**: MCP tools (add_task, list_tasks, complete_task, delete_task, update_task) are specified for Phase III (AI-Powered Chatbot). Phase II focuses on web UI and RESTful API endpoints. MCP integration will be implemented in Phase III according to constitution.

### ✅ Code Quality and Best Practices (Section VII)
- [x] **Security**: JWT verification, input validation, no hard-coded secrets, SQL injection prevention via SQLModel ✓
- [x] **Testing**: Backend pytest for CRUD, user isolation, JWT verification, recurring tasks ✓
- [x] **Performance**: Efficient queries with indexing, connection pooling, horizontal scaling ready ✓
- [x] **Documentation**: README.md, CLAUDE.md, API docs (OpenAPI/Swagger) ✓

### ✅ Bonus Features (Section VIII)
- [x] Task priorities (High, Medium, Low) ✓
- [x] Tags and categories ✓
- [x] Filter and sort options (by date, priority, status, tag) ✓
- [x] Recurring tasks (daily, weekly, monthly) ✓
- [x] Due dates ✓

### Constitution Compliance Summary
**Status**: ✅ PASS (with Phase III deferral noted)

All Phase II requirements align with constitution. MCP tools deferred to Phase III as specified in constitution Section II. No violations requiring complexity justification.

## Project Structure

### Documentation (this feature)

```text
specs/001-fullstack-web-app/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (in progress)
├── research.md          # Phase 0 output (pending)
├── data-model.md        # Phase 1 output (pending)
├── quickstart.md        # Phase 1 output (pending)
├── contracts/           # Phase 1 output (pending)
│   ├── api-endpoints.md
│   ├── database-schema.md
│   └── auth-flow.md
├── checklists/
│   └── requirements.md  # Spec quality checklist (completed)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
# Monorepo Structure (Web Application)

backend/
├── app/
│   ├── main.py              # FastAPI app entry point
│   ├── config.py            # Pydantic settings
│   ├── database.py          # SQLModel engine + session
│   ├── models/
│   │   ├── user.py          # User model (Better Auth)
│   │   └── task.py          # Task model with user_id FK
│   ├── schemas/
│   │   └── task.py          # Pydantic request/response schemas
│   ├── api/
│   │   ├── deps.py          # Dependency injection (get_current_user)
│   │   └── v1/
│   │       ├── router.py    # API router
│   │       └── endpoints/
│   │           └── tasks.py # Task CRUD endpoints
│   ├── middleware/
│   │   └── auth.py          # JWT verification middleware
│   ├── utils/
│   │   └── jwt.py           # JWT decode/verify utilities
│   └── jobs/
│       └── recurring_tasks.py # APScheduler job
├── alembic/
│   ├── versions/
│   │   └── 001_initial.py   # Initial migration
│   └── env.py
├── tests/
│   ├── test_tasks.py        # Task endpoint tests
│   ├── test_auth.py         # JWT verification tests
│   └── test_recurring.py    # Recurring task logic tests
├── pyproject.toml           # UV dependencies
├── Dockerfile
└── .env.example

frontend/
├── app/
│   ├── layout.tsx           # Root layout with QueryClient
│   ├── page.tsx             # Landing page
│   ├── (auth)/
│   │   ├── login/
│   │   │   └── page.tsx     # Login page
│   │   └── signup/
│   │       └── page.tsx     # Signup page
│   ├── (protected)/
│   │   └── todo/
│   │       ├── page.tsx     # Main todo page
│   │       ├── layout.tsx   # Todo layout with sidebar
│   │       └── components/
│   │           ├── TaskList.tsx
│   │           ├── TaskForm.tsx
│   │           ├── TagSidebar.tsx
│   │           ├── CalendarView.tsx
│   │           └── TaskFilters.tsx
│   └── api/
│       └── auth/
│           └── [...all]/
│               └── route.ts # Better Auth handler
├── lib/
│   ├── auth.ts              # Better Auth config
│   └── api-client.ts        # API client with JWT
├── hooks/
│   └── useTasks.ts          # TanStack Query hooks
├── types/
│   └── task.ts              # TypeScript types
├── components/
│   └── ui/                  # shadcn/ui components
├── middleware.ts            # Protected route middleware
├── package.json
├── next.config.js
├── tailwind.config.ts
├── tsconfig.json
└── .env.local.example

docker/
├── docker-compose.yml       # Orchestrate postgres, backend, frontend
├── backend.Dockerfile
└── frontend.Dockerfile

# Existing files (preserved for reference)
src/
├── main.py                  # Phase I console app (keep for reference)
└── todo.py                  # Phase I business logic (keep for reference)

tests/                       # Phase I tests (keep for reference)
```

**Structure Decision**: Web application monorepo structure selected based on "frontend" + "backend" detection in requirements. Clear separation between Next.js frontend and FastAPI backend with shared database (Neon PostgreSQL). Docker Compose for local development orchestration. Existing Phase I console app preserved in src/ for reference during migration.

## Complexity Tracking

> **No violations requiring justification**

All architectural decisions align with constitution requirements. No additional complexity introduced beyond what is specified in Phase II technology stack.

## Phase 0: Research & Technology Validation

### Research Topics

1. **Better Auth + FastAPI JWT Integration**
   - **Question**: How to share JWT secret between Better Auth (Next.js) and FastAPI for token verification?
   - **Research**: Better Auth JWT plugin configuration, PyJWT verification setup, shared secret management
   - **Output**: Detailed authentication flow diagram, environment variable configuration

2. **Neon PostgreSQL Connection Pooling**
   - **Question**: What are best practices for SQLModel connection pooling with Neon serverless PostgreSQL?
   - **Research**: Neon connection limits, SQLModel engine configuration, pool sizing recommendations
   - **Output**: Database configuration with optimal pool settings

3. **APScheduler Reliability for Recurring Tasks**
   - **Question**: How to ensure APScheduler runs reliably in production (single container)?
   - **Research**: APScheduler persistence, job idempotency, missed execution handling
   - **Output**: Scheduler configuration with error handling and logging

4. **shadcn/ui + Tailwind CSS Setup**
   - **Question**: What is the recommended setup for shadcn/ui with Next.js 15 App Router?
   - **Research**: shadcn/ui installation, component customization, Tailwind config
   - **Output**: Component installation checklist, theme configuration

5. **TanStack Query Optimistic Updates**
   - **Question**: How to implement optimistic updates for todo CRUD operations?
   - **Research**: TanStack Query mutation patterns, rollback strategies, cache invalidation
   - **Output**: Hook patterns for create/update/delete with optimistic UI

6. **React Big Calendar Integration**
   - **Question**: How to integrate react-big-calendar with Next.js and style with Tailwind?
   - **Research**: Calendar component setup, event mapping, custom styling
   - **Output**: Calendar component implementation guide

### Research Deliverables

**File**: `specs/001-fullstack-web-app/research.md`

**Contents**:
- Authentication flow diagram (Better Auth → JWT → FastAPI)
- Database connection configuration
- Scheduler setup and reliability patterns
- Frontend component setup guides
- API client patterns with JWT injection
- Optimistic update patterns

## Phase 1: Design & Contracts

### Data Model

**File**: `specs/001-fullstack-web-app/data-model.md`

**Entities**:

1. **User** (Better Auth managed)
   - id: TEXT (primary key)
   - email: TEXT (unique, not null)
   - name: TEXT (nullable)
   - email_verified: BOOLEAN (default false)
   - created_at: TIMESTAMP (default now)
   - updated_at: TIMESTAMP (default now)

2. **Task**
   - id: SERIAL (primary key)
   - user_id: TEXT (foreign key → users.id, cascade delete)
   - title: VARCHAR(200) (not null)
   - description: TEXT (nullable)
   - completed: BOOLEAN (default false)
   - priority: VARCHAR(10) (not null, check: High/Medium/Low)
   - tags: TEXT[] (default empty array)
   - due_date: DATE (nullable)
   - recurring: VARCHAR(20) (nullable, check: daily/weekly/monthly)
   - created_at: TIMESTAMP (default now)
   - updated_at: TIMESTAMP (default now)

**Relationships**:
- User 1:N Task (one user has many tasks)
- Task.user_id → User.id (foreign key with cascade delete)

**Indexes**:
- idx_tasks_user_id ON tasks(user_id) - for user isolation queries
- idx_tasks_completed ON tasks(completed) - for filtering by status
- idx_tasks_due_date ON tasks(due_date) - for calendar view and sorting
- idx_tasks_tags ON tasks USING GIN(tags) - for tag filtering

**Validation Rules**:
- Title: required, max 200 characters
- Description: optional, max 2000 characters
- Priority: must be "High", "Medium", or "Low"
- Tags: max 10 tags per task, each tag max 50 characters
- Recurring: if set, must be "daily", "weekly", or "monthly"
- User_id: required, must reference existing user

### API Contracts

**File**: `specs/001-fullstack-web-app/contracts/api-endpoints.md`

**Base URL**: `http://localhost:8000/api/v1` (development)

**Authentication**: All endpoints require `Authorization: Bearer <jwt_token>` header (except public endpoints)

**Endpoints**:

1. **GET /tasks**
   - Description: List all tasks for authenticated user with optional filters
   - Query Parameters: tag (string), priority (string), completed (boolean), sort (string: created_at|priority|due_date|title)
   - Response: 200 OK, Task[]
   - User Isolation: Automatic filter by user_id from JWT

2. **POST /tasks**
   - Description: Create new task for authenticated user
   - Request Body: { title, description?, priority?, tags?, due_date?, recurring? }
   - Response: 201 Created, Task
   - User Isolation: user_id automatically set from JWT

3. **GET /tasks/{id}**
   - Description: Get task by ID for authenticated user
   - Response: 200 OK, Task | 404 Not Found
   - User Isolation: Verify task.user_id matches JWT user_id

4. **PUT /tasks/{id}**
   - Description: Update task for authenticated user
   - Request Body: { title?, description?, priority?, tags?, due_date?, recurring? }
   - Response: 200 OK, Task | 404 Not Found
   - User Isolation: Verify task.user_id matches JWT user_id

5. **PATCH /tasks/{id}/complete**
   - Description: Toggle task completion status
   - Response: 200 OK, Task | 404 Not Found
   - User Isolation: Verify task.user_id matches JWT user_id

6. **DELETE /tasks/{id}**
   - Description: Delete task for authenticated user
   - Response: 204 No Content | 404 Not Found
   - User Isolation: Verify task.user_id matches JWT user_id

**Error Responses**:
- 401 Unauthorized: Invalid or expired JWT token
- 403 Forbidden: User attempting to access another user's task
- 404 Not Found: Task not found or doesn't belong to user
- 422 Unprocessable Entity: Validation error (invalid input)
- 500 Internal Server Error: Server error

### Authentication Flow

**File**: `specs/001-fullstack-web-app/contracts/auth-flow.md`

**Flow Diagram**:

```
1. User visits /login page (Next.js frontend)
   ↓
2. User enters email/password OR clicks "Sign in with Google"
   ↓
3. Better Auth validates credentials
   ↓
4. Better Auth creates session in database (users table)
   ↓
5. Better Auth generates JWT token with payload:
   {
     "sub": "user_id",
     "email": "user@example.com",
     "name": "User Name",
     "iat": 1234567890,
     "exp": 1234654290
   }
   ↓
6. JWT signed with BETTER_AUTH_SECRET using HS256
   ↓
7. Frontend stores JWT in httpOnly cookie
   ↓
8. User navigates to /todo page
   ↓
9. Frontend makes API call: GET /api/v1/tasks
   ↓
10. API client extracts JWT from cookie, adds to header:
    Authorization: Bearer <token>
   ↓
11. Request reaches FastAPI backend
   ↓
12. JWT Verification Middleware:
    - Extracts token from Authorization header
    - Verifies signature using BETTER_AUTH_SECRET
    - Checks expiration
    - Decodes payload to get user_id
   ↓
13. If valid: Attach user to request.state.user
    If invalid: Return 401 Unauthorized
   ↓
14. Endpoint handler uses dependency injection:
    current_user: User = Depends(get_current_user)
   ↓
15. Database query filters by user_id:
    tasks = db.query(Task).filter(Task.user_id == current_user.id).all()
   ↓
16. Response sent back to frontend with only user's tasks
   ↓
17. Frontend displays tasks in UI
```

**Shared Secret Configuration**:
- Frontend: `BETTER_AUTH_SECRET` in .env.local
- Backend: `JWT_SECRET_KEY` in .env
- **CRITICAL**: These MUST be identical for JWT verification to work

### Database Schema

**File**: `specs/001-fullstack-web-app/contracts/database-schema.md`

**SQL Schema**:

```sql
-- Users table (managed by Better Auth)
CREATE TABLE users (
    id TEXT PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    email_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Tasks table
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    completed BOOLEAN DEFAULT FALSE,
    priority VARCHAR(10) NOT NULL CHECK (priority IN ('High', 'Medium', 'Low')),
    tags TEXT[] DEFAULT '{}',
    due_date DATE,
    recurring VARCHAR(20) CHECK (recurring IN ('daily', 'weekly', 'monthly')),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_completed ON tasks(completed);
CREATE INDEX idx_tasks_due_date ON tasks(due_date);
CREATE INDEX idx_tasks_tags ON tasks USING GIN(tags);
```

**Migration Strategy**:
- Use Alembic for database migrations
- Initial migration creates users and tasks tables
- Indexes created in same migration for optimal performance
- Better Auth handles users table schema automatically

### Quickstart Guide

**File**: `specs/001-fullstack-web-app/quickstart.md`

**Contents**:
1. Prerequisites (Node.js 18+, Python 3.12+, Neon account, Google OAuth credentials)
2. Environment setup (.env files for frontend and backend)
3. Database setup (Neon PostgreSQL connection string)
4. Backend setup (UV install, Alembic migrations, run server)
5. Frontend setup (npm install, run dev server)
6. Docker Compose setup (optional, for local development)
7. Testing instructions (backend pytest, manual frontend testing)
8. Deployment guide (Vercel for frontend, Hugging Face Spaces for backend)

## Implementation Phases

### Phase A: Foundation (Backend Core)
**Duration**: 2 weeks
**Deliverables**:
1. Monorepo structure setup
2. Backend FastAPI app with SQLModel models
3. Alembic migrations for database schema
4. JWT verification middleware
5. Task CRUD API endpoints with user isolation
6. APScheduler for recurring tasks
7. Backend tests (pytest)

### Phase B: Frontend Core (Authentication & UI)
**Duration**: 3 weeks
**Deliverables**:
1. Next.js 15 App Router setup
2. Better Auth configuration (Email/Password + Google OAuth)
3. API client with JWT injection
4. shadcn/ui component installation
5. Login/Signup pages
6. Protected route middleware
7. Task list UI with filters
8. Task form (create/edit modal)

### Phase C: Advanced UI (Tags & Calendar)
**Duration**: 1 week
**Deliverables**:
1. Tag sidebar with filtering
2. Calendar view with react-big-calendar
3. Animated transitions
4. Mobile responsiveness
5. UI polish and loading states

### Phase D: Testing & Deployment
**Duration**: 1 week
**Deliverables**:
1. Backend test suite completion
2. Manual frontend testing
3. Documentation (README, API docs, quickstart)
4. Environment variable templates
5. Deployment to Vercel + Hugging Face Spaces
6. Production smoke testing

## Risk Analysis & Mitigation

### Risk 1: Better Auth + FastAPI JWT Integration Complexity
**Impact**: High - Core authentication flow
**Probability**: Medium
**Mitigation**:
- Research Better Auth JWT plugin thoroughly in Phase 0
- Test JWT verification independently before endpoint integration
- Document shared secret configuration clearly
- Create integration tests for auth flow

### Risk 2: Recurring Task Scheduler Reliability
**Impact**: Medium - Tasks may not generate on time
**Probability**: Medium
**Mitigation**:
- Run scheduler every minute (not hourly) to catch missed tasks
- Implement idempotency (don't create duplicate tasks)
- Add comprehensive logging for scheduler execution
- Plan migration to Celery in Phase V for production reliability

### Risk 3: User Data Isolation Bugs
**Impact**: Critical - Security vulnerability
**Probability**: Low (with proper implementation)
**Mitigation**:
- Always filter by user_id in database queries
- Use dependency injection (get_current_user) consistently
- Write tests to verify users can't access other users' tasks
- Code review all endpoint implementations

### Risk 4: Frontend State Management Complexity
**Impact**: Medium - UI bugs and performance issues
**Probability**: Low (with TanStack Query)
**Mitigation**:
- Use TanStack Query for server state (automatic caching)
- Keep UI state minimal (sidebar open/closed, selected tag)
- Implement optimistic updates for better UX
- Test edge cases (network errors, stale data)

### Risk 5: Mobile Responsiveness
**Impact**: Medium - Poor mobile UX
**Probability**: Low (with Tailwind)
**Mitigation**:
- Design mobile-first with Tailwind breakpoints
- Test on real devices (not just browser DevTools)
- Use shadcn/ui responsive components
- Implement tag sidebar as drawer on mobile

## Success Criteria

### Functional Requirements (from spec.md)
- ✅ User can sign up with email/password
- ✅ User can log in with Google OAuth
- ✅ User can create/edit/delete tasks
- ✅ User can mark tasks complete
- ✅ User can filter by tag, priority, status
- ✅ User can view tasks in calendar by due date
- ✅ Recurring tasks auto-generate on schedule
- ✅ Tag sidebar shows all unique tags with counts
- ✅ Mobile-responsive design

### Non-Functional Requirements (from spec.md)
- ✅ All API endpoints require JWT authentication
- ✅ Users can only access their own tasks (data isolation)
- ✅ Database persists data (Neon PostgreSQL)
- ✅ Smooth animations (calendar expand/collapse, transitions)
- ✅ Fast page loads (<2s initial, <500ms interactions)
- ✅ Accessible UI (keyboard navigation, ARIA labels)

### Technical Requirements
- ✅ Monorepo structure with frontend/ and backend/
- ✅ Docker Compose for local development
- ✅ Alembic migrations for database schema
- ✅ Comprehensive tests (backend pytest)
- ✅ Environment variable validation (Pydantic Settings)
- ✅ API documentation (OpenAPI/Swagger via FastAPI)

## Next Steps

1. **Approve this plan** - Review and approve implementation plan
2. **Run `/sp.tasks`** - Generate actionable task breakdown
3. **Run `/sp.implement`** - Execute tasks in dependency order
4. **Use agents** - Deploy general-purpose agents for each phase
5. **Run `/sp.analyze`** - Verify consistency across artifacts
6. **Run `/sp.git.commit_pr`** - Commit and create pull request

## Appendix: Technology Stack Details

### Frontend Stack
- **Next.js 15.1.0+**: React framework with App Router, server components, API routes
- **TypeScript 5.3+**: Type safety for frontend code
- **React 19+**: UI library with concurrent features
- **shadcn/ui**: Accessible component library built on Radix UI
- **Tailwind CSS 3.4+**: Utility-first CSS framework
- **Better Auth 1.0+**: Authentication library with JWT plugin
- **TanStack Query 5.0+**: Server state management with caching
- **React Hook Form 7.50+**: Form state management
- **Zod 3.22+**: Schema validation
- **react-big-calendar 1.8+**: Calendar component

### Backend Stack
- **FastAPI 0.109+**: Modern Python web framework with automatic OpenAPI docs
- **SQLModel 0.0.14+**: ORM combining SQLAlchemy and Pydantic
- **Alembic 1.13+**: Database migration tool
- **PyJWT 2.8+**: JWT token verification
- **APScheduler 3.10+**: Background job scheduler for recurring tasks
- **Uvicorn 0.27+**: ASGI server for FastAPI
- **Pydantic Settings**: Environment variable validation

### Database
- **Neon PostgreSQL**: Serverless PostgreSQL with auto-scaling, connection pooling, branching

### Deployment
- **Frontend**: Vercel (serverless Next.js, edge functions, automatic HTTPS)
- **Backend**: Hugging Face Spaces or Railway/Render (Docker container, automatic deployments)
- **Database**: Neon (serverless, managed, automatic backups)

---

**Plan Status**: ✅ Ready for Phase 0 Research
**Next Command**: Generate research.md and proceed to Phase 1 design
