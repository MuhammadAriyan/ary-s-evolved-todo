# Database Schema Contract

**Feature**: 001-fullstack-web-app
**Date**: 2026-01-06
**Version**: 1.0.0

## Overview

This document defines the complete database schema for the full-stack todo application using Neon PostgreSQL. The schema supports multi-user isolation, task management with tags, priorities, due dates, and recurring patterns.

---

## Database Configuration

**Provider**: Neon PostgreSQL (serverless)
**Version**: PostgreSQL 15+
**Connection**: SSL required
**Pooling**: Managed by SQLModel (pool_size=5, max_overflow=10)

---

## Tables

### users

**Description**: Stores user account information. Managed by Better Auth.

```sql
CREATE TABLE users (
    id TEXT PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    email_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

**Columns**:
- `id` (TEXT, PRIMARY KEY): Unique user identifier generated by Better Auth
- `email` (TEXT, UNIQUE, NOT NULL): User's email address
- `name` (TEXT, NULLABLE): User's display name
- `email_verified` (BOOLEAN, DEFAULT FALSE): Email verification status
- `created_at` (TIMESTAMP, DEFAULT NOW()): Account creation timestamp
- `updated_at` (TIMESTAMP, DEFAULT NOW()): Last update timestamp

**Constraints**:
- PRIMARY KEY on `id`
- UNIQUE constraint on `email`
- NOT NULL constraint on `email`

**Indexes**:
- Automatic index on `id` (primary key)
- Automatic index on `email` (unique constraint)

---

### tasks

**Description**: Stores todo items with user isolation.

```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    completed BOOLEAN DEFAULT FALSE,
    priority VARCHAR(10) NOT NULL CHECK (priority IN ('High', 'Medium', 'Low')),
    tags TEXT[] DEFAULT '{}',
    due_date DATE,
    recurring VARCHAR(20) CHECK (recurring IN ('daily', 'weekly', 'monthly')),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

**Columns**:
- `id` (SERIAL, PRIMARY KEY): Auto-incrementing task identifier
- `user_id` (TEXT, FOREIGN KEY, NOT NULL): Owner of the task
- `title` (VARCHAR(200), NOT NULL): Task title/summary
- `description` (TEXT, NULLABLE): Detailed task description
- `completed` (BOOLEAN, DEFAULT FALSE): Completion status
- `priority` (VARCHAR(10), NOT NULL): Task priority (High, Medium, Low)
- `tags` (TEXT[], DEFAULT '{}'): Array of tag strings
- `due_date` (DATE, NULLABLE): When the task is due
- `recurring` (VARCHAR(20), NULLABLE): Recurrence pattern
- `created_at` (TIMESTAMP, DEFAULT NOW()): Task creation timestamp
- `updated_at` (TIMESTAMP, DEFAULT NOW()): Last update timestamp

**Constraints**:
- PRIMARY KEY on `id`
- FOREIGN KEY `user_id` REFERENCES `users(id)` ON DELETE CASCADE
- NOT NULL constraints on `user_id`, `title`, `priority`
- CHECK constraint on `priority`: must be 'High', 'Medium', or 'Low'
- CHECK constraint on `recurring`: if not null, must be 'daily', 'weekly', or 'monthly'

**Indexes**:
- `idx_tasks_user_id` ON `user_id` (B-tree)
- `idx_tasks_completed` ON `completed` (B-tree)
- `idx_tasks_due_date` ON `due_date` (B-tree)
- `idx_tasks_tags` ON `tags` USING GIN (Generalized Inverted Index)

---

## Indexes

### idx_tasks_user_id

```sql
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
```

**Purpose**: Optimize user isolation queries (most common query pattern)
**Type**: B-tree
**Columns**: user_id
**Usage**: Every task query filters by user_id
**Impact**: Critical for performance

---

### idx_tasks_completed

```sql
CREATE INDEX idx_tasks_completed ON tasks(completed);
```

**Purpose**: Optimize filtering by completion status
**Type**: B-tree
**Columns**: completed
**Usage**: "All/Pending/Completed" filters
**Impact**: Improves filter performance

---

### idx_tasks_due_date

```sql
CREATE INDEX idx_tasks_due_date ON tasks(due_date);
```

**Purpose**: Optimize calendar view and sorting by due date
**Type**: B-tree
**Columns**: due_date
**Usage**: Calendar queries, date-based sorting, recurring task scheduler
**Impact**: Essential for calendar performance

---

### idx_tasks_tags

```sql
CREATE INDEX idx_tasks_tags ON tasks USING GIN(tags);
```

**Purpose**: Optimize tag filtering queries
**Type**: GIN (Generalized Inverted Index)
**Columns**: tags (array)
**Usage**: Tag sidebar filtering, "contains tag" queries
**Impact**: Enables efficient array containment queries

---

## Relationships

### users → tasks (One-to-Many)

```
users (1) ──────< (N) tasks
  id                   user_id
```

**Relationship**: One user has many tasks
**Foreign Key**: tasks.user_id → users.id
**Cascade**: ON DELETE CASCADE (deleting user deletes all their tasks)
**Enforcement**: Database-level foreign key constraint

---

## Data Types

### PostgreSQL Types Used

- **TEXT**: Variable-length character string (unlimited length)
- **VARCHAR(n)**: Variable-length character string (max n characters)
- **SERIAL**: Auto-incrementing integer (equivalent to INTEGER with sequence)
- **BOOLEAN**: True/false value
- **DATE**: Calendar date (year, month, day)
- **TIMESTAMP**: Date and time (without timezone)
- **TEXT[]**: Array of text values

---

## Constraints

### Primary Keys
- `users.id`: Ensures unique user identification
- `tasks.id`: Ensures unique task identification

### Foreign Keys
- `tasks.user_id → users.id`: Ensures referential integrity, cascades deletes

### Unique Constraints
- `users.email`: Prevents duplicate email registrations

### Check Constraints
- `tasks.priority IN ('High', 'Medium', 'Low')`: Validates priority values
- `tasks.recurring IN ('daily', 'weekly', 'monthly')`: Validates recurring patterns

### Not Null Constraints
- `users.email`: Email required for authentication
- `tasks.user_id`: Every task must belong to a user
- `tasks.title`: Every task must have a title
- `tasks.priority`: Every task must have a priority

---

## Default Values

- `users.email_verified`: FALSE (email not verified by default)
- `users.created_at`: NOW() (current timestamp)
- `users.updated_at`: NOW() (current timestamp)
- `tasks.completed`: FALSE (tasks not completed by default)
- `tasks.tags`: '{}' (empty array)
- `tasks.created_at`: NOW() (current timestamp)
- `tasks.updated_at`: NOW() (current timestamp)

---

## Migration Scripts

### Initial Migration (Alembic)

**File**: `backend/alembic/versions/001_initial.py`

```python
"""Initial migration: users and tasks tables

Revision ID: 001
Revises:
Create Date: 2026-01-06
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    # Create users table
    op.create_table(
        'users',
        sa.Column('id', sa.Text(), nullable=False),
        sa.Column('email', sa.Text(), nullable=False),
        sa.Column('name', sa.Text(), nullable=True),
        sa.Column('email_verified', sa.Boolean(), server_default='false', nullable=False),
        sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email')
    )

    # Create tasks table
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer(), nullable=False, autoincrement=True),
        sa.Column('user_id', sa.Text(), nullable=False),
        sa.Column('title', sa.String(length=200), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('completed', sa.Boolean(), server_default='false', nullable=False),
        sa.Column('priority', sa.String(length=10), nullable=False),
        sa.Column('tags', postgresql.ARRAY(sa.Text()), server_default='{}', nullable=False),
        sa.Column('due_date', sa.Date(), nullable=True),
        sa.Column('recurring', sa.String(length=20), nullable=True),
        sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
        sa.CheckConstraint("priority IN ('High', 'Medium', 'Low')", name='check_priority'),
        sa.CheckConstraint("recurring IS NULL OR recurring IN ('daily', 'weekly', 'monthly')", name='check_recurring')
    )

    # Create indexes
    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('idx_tasks_completed', 'tasks', ['completed'])
    op.create_index('idx_tasks_due_date', 'tasks', ['due_date'])
    op.create_index('idx_tasks_tags', 'tasks', ['tags'], postgresql_using='gin')

def downgrade():
    op.drop_index('idx_tasks_tags', table_name='tasks')
    op.drop_index('idx_tasks_due_date', table_name='tasks')
    op.drop_index('idx_tasks_completed', table_name='tasks')
    op.drop_index('idx_tasks_user_id', table_name='tasks')
    op.drop_table('tasks')
    op.drop_table('users')
```

---

## Query Patterns

### Common Queries

#### 1. List user's tasks with filters

```sql
SELECT * FROM tasks
WHERE user_id = $1
  AND ($2::text IS NULL OR $2 = ANY(tags))
  AND ($3::text IS NULL OR priority = $3)
  AND ($4::boolean IS NULL OR completed = $4)
ORDER BY
  CASE WHEN $5 = 'priority' THEN priority END DESC,
  CASE WHEN $5 = 'due_date' THEN due_date END ASC,
  CASE WHEN $5 = 'title' THEN title END ASC,
  created_at DESC;
```

**Parameters**:
- $1: user_id (required)
- $2: tag filter (optional)
- $3: priority filter (optional)
- $4: completed filter (optional)
- $5: sort field (optional)

**Indexes Used**: idx_tasks_user_id, idx_tasks_tags (if tag filter), idx_tasks_completed (if completed filter)

---

#### 2. Create task

```sql
INSERT INTO tasks (user_id, title, description, priority, tags, due_date, recurring)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING *;
```

**Parameters**:
- $1: user_id
- $2: title
- $3: description
- $4: priority
- $5: tags (array)
- $6: due_date
- $7: recurring

---

#### 3. Get task by ID with user isolation

```sql
SELECT * FROM tasks
WHERE id = $1 AND user_id = $2;
```

**Parameters**:
- $1: task_id
- $2: user_id (from JWT)

**Indexes Used**: Primary key on id, idx_tasks_user_id

---

#### 4. Update task

```sql
UPDATE tasks
SET title = COALESCE($3, title),
    description = COALESCE($4, description),
    priority = COALESCE($5, priority),
    tags = COALESCE($6, tags),
    due_date = COALESCE($7, due_date),
    recurring = COALESCE($8, recurring),
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING *;
```

**Parameters**:
- $1: task_id
- $2: user_id (from JWT)
- $3-$8: updated fields (nullable)

---

#### 5. Toggle completion

```sql
UPDATE tasks
SET completed = NOT completed,
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING *;
```

---

#### 6. Delete task

```sql
DELETE FROM tasks
WHERE id = $1 AND user_id = $2;
```

---

#### 7. Find recurring tasks due for generation

```sql
SELECT * FROM tasks
WHERE recurring IS NOT NULL
  AND due_date <= CURRENT_DATE;
```

**Indexes Used**: idx_tasks_due_date

---

## Performance Considerations

### Index Usage
- All user queries use `idx_tasks_user_id` (critical)
- Tag filtering uses `idx_tasks_tags` (GIN index for array containment)
- Calendar queries use `idx_tasks_due_date`
- Status filtering uses `idx_tasks_completed`

### Query Optimization
- Always filter by `user_id` first (most selective)
- Use parameterized queries (prevents SQL injection, enables query plan caching)
- Limit result sets where appropriate
- Use EXPLAIN ANALYZE to verify index usage

### Connection Pooling
- Pool size: 5 persistent connections
- Max overflow: 10 additional connections
- Pool pre-ping: Verify connection before use
- Pool recycle: 3600 seconds (1 hour)

---

## Security

### User Isolation
- Every query MUST filter by `user_id` from authenticated JWT token
- Foreign key constraint ensures referential integrity
- Cascade delete prevents orphaned tasks

### SQL Injection Prevention
- Use parameterized queries (SQLModel/SQLAlchemy)
- Never concatenate user input into SQL strings
- Validate all inputs with Pydantic schemas

### Data Encryption
- SSL/TLS required for database connections (Neon enforces this)
- Passwords hashed with bcrypt (handled by Better Auth)
- JWT tokens signed with HS256 algorithm

---

## Backup and Recovery

### Neon Automatic Backups
- Point-in-time recovery (PITR) available
- Backups retained for 7 days (free tier)
- Restore to any point within retention period

### Manual Backup

```bash
# Export database to SQL file
pg_dump $DATABASE_URL > backup.sql

# Restore from SQL file
psql $DATABASE_URL < backup.sql
```

---

## Monitoring

### Key Metrics to Monitor
- Connection pool usage
- Query execution time (p95, p99)
- Index hit rate (should be >99%)
- Table size growth
- Slow query log

### Neon Dashboard
- Query performance insights
- Connection statistics
- Storage usage
- CPU and memory metrics

---

**Database Schema Status**: ✅ Complete
**Version**: 1.0.0
**Last Updated**: 2026-01-06
