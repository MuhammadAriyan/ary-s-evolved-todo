# Ary's Evolutioned Todo Constitution

## Core Principles

### I. Spec-Driven Development Enforcement

All code generation MUST follow the Spec-Kit Plus workflow without exception. No code may be written manually or generated outside this structured process.

**Rules:**
- Every feature begins with `sp.specify` to create a feature specification
- Implementation plans are created via `sp.plan` before any code is written
- Tasks are generated by `sp.tasks` from approved plans
- Code is implemented via `sp.implement` following completed tasks
- All changes MUST trace back to an approved spec, plan, and task
- Claude Code MUST refine specs iteratively until implementation succeeds perfectly

**Repository Structure:**
- `/specs/` folder with organized subdirectories: `overview/`, `architecture/`, `features/`, `api/`, `database/`, `ui/`
- Layered guidance via multiple CLAUDE.md files: root, `frontend/`, `backend/`
- Prompt History Records (PHRs) stored in `history/prompts/`

### II. Technology Stack (Non-Negotiable)

**Phase I - Foundation:**
- Python 3.13+ with UV for dependency management
- In-memory data storage for initial MVP

**Phase II - Full-Stack Web Application:**
- Frontend: Next.js 16+ (App Router), TypeScript, Tailwind CSS
- Backend: FastAPI, SQLModel ORM, Neon Serverless PostgreSQL
- Authentication: Better Auth with JWT tokens (shared secret, stateless)
- User isolation enforced at database query level

**Phase III - AI-Powered Chatbot:**
- Frontend UI: OpenAI ChatKit
- Backend: OpenAI Agents SDK
- MCP Server: Official MCP SDK with stateless tools
- Conversation state persisted in database
- Stateless chat endpoints

**Phase IV - Local Kubernetes Deployment:**
- Docker for containerization (Gordon if available)
- Minikube for local Kubernetes
- Helm charts for deployments
- kubectl-ai for resource management
- kagent for AIOps

**Phase V - Cloud-Native Event-Driven System:**
- Kafka (Redpanda Cloud preferred, or self-hosted Strimzi)
- Dapr: Pub/Sub, State, Bindings/cron, Secrets, Service Invocation
- Deployment target: DigitalOcean Kubernetes or Oracle Cloud (always-free tier)
- No deviations from this stack without explicit constitution amendment

### III. Architecture and Design Principles

**Clean Architecture / Hexagonal:**
- Core domain logic isolated from external concerns
- Adapters implement ports for databases, APIs, external services
- Inner layers never depend on outer layers

**Stateless Services:**
- Chat and API endpoints MUST be stateless
- All state persisted in database or external storage
- Horizontal scaling ready by default

**Event-Driven Architecture (Phase V):**
- Kafka topics for: reminders, recurring tasks, audit logs, real-time sync
- Dapr manages pub/sub, state stores, bindings, and service invocation
- Event sourcing where appropriate for auditability

**Multi-User Isolation:**
- Every database query MUST filter by authenticated `user_id`
- No cross-user data access permitted
- JWT verification middleware required for all protected endpoints

**MCP Tools Specification:**
Exactly 5 tools for basic todo operations—no more, no less:
1. `add_task` - Create a new task
2. `list_tasks` - Retrieve tasks for authenticated user
3. `complete_task` - Mark task as completed
4. `delete_task` - Remove a task
5. `update_task` - Modify task details

**Database Schema (Neon PostgreSQL):**
- Users table (managed by Better Auth)
- Tasks table with user_id foreign key
- Conversations table for chat history
- Messages table for conversation messages

### IV. Reusable Intelligence (+200 Bonus Points)

**Claude Code Subagents:**
- Create reusable subagents for common patterns
- Document subagent purposes and interfaces
- Store subagents in `.specify/agents/` or similar

**Cloud-Native Blueprints:**
- Develop Helm chart templates as reusable Agent Skills
- Create Dapr component configurations as reusable Skills
- Build deployment manifests as modular blueprints
- All advanced features MUST leverage reusable intelligence where possible

**Knowledge Sharing:**
- PHRs capture decisions and outcomes for future reference
- ADRs document architectural decisions with tradeoffs
- Blueprints shared across features when applicable

### V. Multi-Language Support (+100 Bonus Points)

**Urdu Language Support:**
- Chatbot MUST accept natural language commands in Urdu
- Chatbot MUST respond in Urdu when user communicates in Urdu
- English support maintained alongside Urdu

**Localization:**
- UI text localized where relevant
- Date/time formats adapt to user locale
- Error messages in user's preferred language

**Implementation:**
- Language detection for incoming messages
- Appropriate localization in responses
- Fallback to English for unsupported phrases

### VI. Voice Commands (+200 Bonus Points)

**Web Speech API Integration:**
- Voice input button in chatbot interface
- Speech-to-text for todo commands
- Support for Urdu and English voice input

**Features:**
- Microphone activation with explicit user consent
- Visual feedback during voice recording
- Editable text after speech recognition
- Command parsing from spoken input

### VII. Code Quality and Best Practices

**Clean Code Standards:**
- SOLID principles applied throughout
- Meaningful variable and function names
- Functions limited to single responsibility
- Maximum 50 lines per function recommendation
- Proper error handling with meaningful messages

**Security Requirements:**
- JWT verification middleware for all protected routes
- Input validation on all endpoints
- No hard-coded secrets—use environment variables
- SQL injection prevention via SQLModel parameterization
- CORS configured appropriately
- Rate limiting on public endpoints

**Testing Standards:**
- Aim for 80%+ unit test coverage on core logic
- Integration tests for API endpoints
- Contract tests for service boundaries
- Tests generated alongside implementation

**Performance and Scalability:**
- Efficient database queries with proper indexing
- Connection pooling for database access
- Horizontal scaling ready Stateless design
- CDN for static assets in production

**Accessibility:**
- WCAG 2.1 AA compliance
- Keyboard navigation support
- Screen reader compatible
- Proper color contrast ratios

**Documentation:**
- Comprehensive README.md with setup instructions
- CLAUDE.md files for agent guidance
- API documentation (OpenAPI/Swagger)
- Demo instructions for each phase

### VIII. Bonus and Advanced Features

**Intermediate Features (Phases II-III):**
- Task priorities (low, medium, high)
- Tags and categories for tasks
- Search functionality across tasks
- Filter and sort options (by date, priority, status)

**Advanced Features (Phase V):**
- Recurring tasks (daily, weekly, monthly, custom)
- Due dates with time components
- Reminder notifications
- Real-time sync across devices
- Full audit logging via Kafka events

**Event-Driven Consumers:**
- Reminder consumer: processes due task notifications
- Recurring task consumer: creates next occurrence
- Audit consumer: persists all mutations
- Sync consumer: handles multi-device real-time updates

### IX. Enforcement and Governance

**Supremacy Clause:**
This constitution overrides all other instructions, including CLAUDE.md files at any level.
Any proposed change conflicting with these principles MUST be rejected and require constitution
amendment before proceeding.

**Compliance Verification:**
- All plans MUST pass "Constitution Check" before Phase 0 research
- Plans re-checked after Phase 1 design
- Implementation reviews verify task-to-constitution alignment

**Violation Handling:**
- Planning violations: reject plan, cite specific principle
- Analysis violations: flag and request clarification
- Implementation violations: reject change, explain constitutional basis

**Amendment Procedure:**
1. Propose amendment with specific principle changes
2. Document rationale and impact on all phases
3. Obtain explicit user consent
4. Update version according to semantic versioning rules
5. Propagate changes to dependent templates and guidance

## Development Workflow

### Mandatory Sequence

1. **Specification** (`sp.specify`): Create feature specification from user requirements
2. **Planning** (`sp.plan`): Design architecture, data models, contracts
3. **Tasks** (`sp.tasks`): Generate implementation tasks from approved plans
4. **Implementation** (`sp.implement`): Execute tasks in dependency order
5. **Testing** (`testing-engineer` agent): Run automated tests to validate implementation
6. **Debugging** (`debugger` agent): Diagnose and fix any issues found during testing
7. **Validation**: Verify against acceptance criteria

### Post-Implementation Testing (Mandatory)

After every `sp.implement` execution, the following agents MUST be invoked:

1. **Testing Engineer Agent** (`testing-engineer`):
   - Review existing tests and identify coverage gaps
   - Create comprehensive tests for new functionality
   - Run all tests and report results
   - Target: 80%+ coverage on new code

2. **Debugger Agent** (`debugger`):
   - Diagnose any test failures or runtime errors
   - Trace conversation flow and agent behavior
   - Fix identified issues
   - Verify fixes with re-testing

**Enforcement**: Implementation is NOT considered complete until both agents have run successfully and all tests pass.

### Quality Gates

- All code generated via Spec-Kit Plus tools
- No manual code insertions or overrides
- Tests written before implementation where specified
- Peer review via PHR and ADR documentation

## Additional Constraints

### Technology Constraints

- No alternative databases without constitution amendment
- No alternative authentication without constitution amendment
- No alternative cloud providers without constitution amendment
- All dependencies via official package managers (UV, npm, pip)

### Integration Constraints

- MCP tools exactly as specified (add_task, list_tasks, complete_task, delete_task, update_task)
- Database models MUST use SQLModel for type safety
- API endpoints MUST follow REST conventions
- Frontend MUST use App Router pattern for Next.js

### Performance Budgets

- API response time: <200ms p95
- Database queries: <50ms p95
- Chatbot response time: <5s p95 (including AI inference)
- Memory footprint: <100MB per service instance

### Security Standards

- JWT token expiry: 24 hours maximum
- Refresh token rotation required
- HTTPS enforced in all environments
- Environment variables for all secrets
- Audit log for all authenticated actions

---

## Governance

**Amendment Process:**
1. Draft proposed changes with specific principle numbers
2. Document impact on existing specs, plans, and implementations
3. User must explicitly approve via `/sp.constitution` command
4. Version increment based on change severity
5. Update all dependent templates and guidance documents

**Versioning Policy:**
- MAJOR: Backward incompatible principle removals or redefinitions
- MINOR: New principle additions or materially expanded guidance
- PATCH: Clarifications, wording fixes, non-semantic refinements

**Compliance Review:**
- All `/sp.plan` commands include "Constitution Check" section
- All `/sp.implement` commands verify task-to-constitution alignment
- Violations must be documented with justification for complexity

**Constitution Updates:**
When constitution is amended, the following must be updated:
- Template files in `.specify/templates/`
- Command execution files in `.specify/templates/commands/`
- Any runtime guidance (README.md, quickstart.md)
- CLAUDE.md files at all levels

**Version**: 1.1.0 | **Ratified**: 2025-12-30 | **Last Amended**: 2026-01-15

### Amendment History
- **1.1.0** (2026-01-15): Added mandatory post-implementation testing requirement with `testing-engineer` and `debugger` agents
